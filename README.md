<h1 align="center">Topic management system</h1>

<details>
 <summary><strong>
  Техническое задание
</strong></summary>

#### ЗАДАНИЕ:

* Разработайте систему управления топиками, которая позволит:
* - Создавать топики (топик состоит из названия и сообщений)
* - Публиковать сообщения в топики.
* - Обрабатывать сообщения от топиков с использованием блокировок и условий.
* - Потребители должны извлекать сообщения по одному и засыпать при отсутствии новых сообщений, просыпаться, 
* когда появится новое сообщение.
* - Сообщения должны сохраняться в списке сообщений, чтобы каждый потребитель мог читать те же сообщения.
* - Для каждого потребителя должен быть механизм сохранения индекса последнего вычитанного сообщения.
* - Для потребителя добавить возможность, передавать CountDownLatch (для ограничения кол-ва читаемых сообщений) и 
* коллекцию для сохранения прочитанных сообщений.
* - Написать тесты.

* Реализовать механизм единовременного доступа к топику(что бы мы могли задать максимальное кол-во потребителей, 
* которые могут читать сообщение из одного и того же топика)
</details>

<details>
 <summary><strong>
  Запуск проекта
</strong></summary>

* Пример работы сервиса реализован в классе Main.
* Объяснение выполнения пунктов задания:
* 1 Создавать топики: Класс Broker имеет функционал добавлять топики с помощью метода addTopic.
* 2 Публиковать сообщения в топики: Класс Topic имеет метод publishMessage для добавления сообщений.
* 3 Обрабатывать сообщения от топиков с использованием блокировок и условий: Класс Consumer использует блокировки и 
* условия для обработки сообщений.
* 4 Потребители должны извлекать сообщения по одному и засыпать при отсутствии новых сообщений, просыпаться, 
* когда появится новое сообщение: Класс Consumer реализует эту логику с помощью await и signalAll.
* 5 Сообщения должны сохраняться в списке сообщений, чтобы каждый потребитель мог читать те же сообщения: Сообщения 
* сохраняются в списке messages в классе Topic.
* 6 Для каждого потребителя должен быть механизм сохранения индекса последнего вычитанного сообщения: Класс Consumer 
* использует lastReadIndex для сохранения индекса последнего вычитанного сообщения.
* 7 Для потребителя добавить возможность, передавать CountDownLatch и коллекцию для сохранения прочитанных сообщений: 
* Класс Consumer принимает CountDownLatch и коллекцию consumedMessages в методе consume.
* 8 Реализовать механизм единовременного доступа к топику: Это реализовано с помощью блокировок в классе Topic.
* Тесты можно запустить с помощью команды `./gradlew test`.

</details>